<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lichess Stats & Analysis Suite</title>
    
    <link rel="icon" type="image/png" href="https://lichess1.org/assets/logo/lichess-favicon-32.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', sans-serif; background: #0a0a0a; color: #e0e0e0; min-height: 100vh; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; }
        
        /* UI Elements */
        .header { text-align: center; margin-bottom: 20px; }
        .header h1 { color: white; margin-bottom: 10px; }
        .tabs { display: flex; justify-content: center; gap: 10px; margin-bottom: 30px; }
        .tab-btn { padding: 10px 25px; background: #1a1a1a; color: #888; border: 2px solid #333; border-radius: 6px; cursor: pointer; }
        .tab-btn.active { background: #667eea; color: white; border-color: #667eea; }
        .view-section { display: none; }
        .view-section.active { display: block; }

        .card { background: #1a1a1a; padding: 20px; border-radius: 12px; margin-bottom: 20px; }
        .input-group { display: flex; gap: 10px; margin-bottom: 15px; }
        input, textarea { flex: 1; padding: 12px; background: #0a0a0a; border: 1px solid #333; color: white; border-radius: 6px; }
        button { padding: 12px 25px; background: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; }
        button:hover { opacity: 0.9; transform: translateY(-1px); }

        /* Analysis Layout */
        .analysis-grid { display: grid; grid-template-columns: minmax(300px, 600px) 1fr; gap: 20px; }
        .board-wrapper { position: relative; }
        .board-container { display: flex; }
        #board { width: 100%; }
        
        .eval-bar-container { width: 15px; background: #333; margin-right: 5px; position: relative; border-radius: 3px; overflow: hidden; }
        .eval-bar-fill { width: 100%; background: #eee; position: absolute; bottom: 0; height: 50%; transition: height 0.3s; }
        
        .move-list { height: 300px; overflow-y: auto; background: #0a0a0a; border: 1px solid #333; padding: 5px; font-family: monospace; }
        .move-row { display: flex; padding: 4px; border-bottom: 1px solid #222; cursor: pointer; }
        .move-row:hover { background: #222; }
        .move-row.active { background: #2c3e50; color: #ecf0f1; }
        .move-row div { flex: 1; }
        
        .stat-box { background: #222; padding: 15px; border-radius: 8px; margin-bottom: 15px; text-align: center; }
        .stat-value { font-size: 1.5rem; font-weight: bold; }
        
        /* Utilities */
        .hidden { display: none !important; }
        .error { background: #e74c3c; color: white; padding: 10px; border-radius: 6px; display: none; margin-bottom: 15px; }
        .loading-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: none; align-items: center; justify-content: center; z-index: 1000; flex-direction: column; }
        .progress-bar { width: 300px; height: 8px; background: #333; margin-top: 15px; border-radius: 4px; overflow: hidden; }
        .progress-fill { height: 100%; width: 0%; background: #667eea; transition: width 0.2s; }
        
        @media (max-width: 900px) { .analysis-grid { grid-template-columns: 1fr; } }
    </style>
</head>
<body>

<div class="container">
    <div class="header">
        <h1>Lichess Suite</h1>
        <div class="tabs">
            <button class="tab-btn active" onclick="switchTab('stats')">Player Stats</button>
            <button class="tab-btn" onclick="switchTab('analysis')">Game Analysis</button>
        </div>
    </div>

    <div class="error" id="globalError"></div>

    <div id="statsView" class="view-section active">
        <div class="card">
            <div class="input-group">
                <input type="text" id="usernameInput" placeholder="Enter Username (e.g. MagnusCarlsen)">
                <button onclick="fetchPlayerStats()">Search</button>
            </div>
        </div>
        <div id="playerData" class="hidden">
            <div class="card" id="playerInfo"></div>
            <div class="card"><canvas id="ratingChart" height="300"></canvas></div>
        </div>
    </div>

    <div id="analysisView" class="view-section">
        <div class="card">
            <div class="input-group">
                <input type="text" id="gameUrlInput" placeholder="Game URL or ID">
                <button onclick="loadFromUrl()">Load URL</button>
            </div>
            <textarea id="pgnInput" rows="3" placeholder="Or paste PGN..."></textarea>
            <button onclick="startAnalysis()" style="width:100%; margin-top:10px; background:#667eea; color:white;">Analyze Game</button>
        </div>

        <div id="analysisDashboard" class="hidden">
            <div class="analysis-grid">
                <div class="board-wrapper">
                    <div class="board-container">
                        <div class="eval-bar-container"><div class="eval-bar-fill" id="evalBarFill"></div></div>
                        <div id="board"></div>
                    </div>
                    <div style="margin-top:10px; display:flex; gap:5px; justify-content:center;">
                        <button onclick="navMove('start')">|&lt;</button>
                        <button onclick="navMove('prev')">&lt;</button>
                        <button onclick="navMove('next')">&gt;</button>
                        <button onclick="navMove('end')">&gt;|</button>
                        <button onclick="board.flip()">Flip</button>
                    </div>
                </div>

                <div>
                    <div class="stat-box">
                        <h4>Accuracy</h4>
                        <div style="display:flex; justify-content:space-around; margin-top:10px;">
                            <div>White: <div class="stat-value" id="accWhite">-</div></div>
                            <div>Black: <div class="stat-value" id="accBlack">-</div></div>
                        </div>
                    </div>
                    <div class="move-list" id="moveList"></div>
                    <div class="card" style="margin-top:20px; height:200px;">
                        <canvas id="evalChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="loading-overlay" id="loader">
    <h3 id="loadingText">Processing...</h3>
    <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
    <button onclick="stopAnalysis()" style="margin-top:20px; background:#e74c3c; color:white; padding:5px 15px; font-size:0.8rem;">Cancel</button>
</div>

<script>
    // --- State & Globals ---
    let chess = new Chess();
    let board = null;
    let engine = null;
    let currentAnalysisId = 0; // Prevents race conditions
    let gameMoves = [];
    let currentMoveIndex = -1;
    let chartInstance = null;
    let statChartInstance = null;

    // --- Tab Handling ---
    function switchTab(tab) {
        document.querySelectorAll('.view-section').forEach(e => e.classList.remove('active'));
        document.querySelectorAll('.tab-btn').forEach(e => e.classList.remove('active'));
        document.getElementById(tab + 'View').classList.add('active');
        event.target.classList.add('active'); // Assumes button click
        
        if(tab === 'analysis' && !board) {
            setTimeout(() => {
                board = Chessboard('board', {
                    position: 'start',
                    draggable: false,
                    pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png'
                });
                window.onresize = board.resize;
            }, 100);
        }
    }

    // --- Stats Logic ---
    async function fetchPlayerStats() {
        const user = document.getElementById('usernameInput').value.trim();
        if(!user) return alert('Enter username');
        
        try {
            const res = await fetch(`https://lichess.org/api/user/${user}`);
            if(!res.ok) throw new Error('User not found');
            const data = await res.json();
            
            document.getElementById('playerData').classList.remove('hidden');
            document.getElementById('playerInfo').innerHTML = `
                <h2>${data.username}</h2>
                <p>Games: ${data.count.all} | Wins: ${data.count.win}</p>
            `;

            // Chart
            if(statChartInstance) statChartInstance.destroy();
            const ctx = document.getElementById('ratingChart').getContext('2d');
            const variants = ['bullet', 'blitz', 'rapid', 'classical'];
            statChartInstance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: variants,
                    datasets: [{
                        label: 'Rating',
                        data: variants.map(v => data.perfs[v]?.rating || 0),
                        backgroundColor: '#667eea'
                    }]
                },
                options: { responsive: true, maintainAspectRatio: false }
            });
        } catch(e) {
            document.getElementById('globalError').innerText = e.message;
            document.getElementById('globalError').style.display = 'block';
        }
    }

    // --- Analysis Logic ---
    async function loadFromUrl() {
        const input = document.getElementById('gameUrlInput').value;
        const id = input.match(/lichess\.org\/([a-zA-Z0-9]{8})/) || [null, input];
        if(!id[1]) return alert('Invalid ID');
        
        showLoader('Downloading Game...');
        try {
            const res = await fetch(`https://lichess.org/game/export/${id[1]}?evals=false&clocks=false`);
            if(!res.ok) throw new Error('Failed to load');
            const pgn = await res.text();
            document.getElementById('pgnInput').value = pgn;
            hideLoader();
            startAnalysis(); // Auto-start
        } catch(e) {
            hideLoader();
            alert(e.message);
        }
    }

    async function startAnalysis() {
        const pgn = document.getElementById('pgnInput').value;
        if(!pgn.trim()) return;

        // Reset
        currentAnalysisId++; // Invalidate previous runs
        const myId = currentAnalysisId;
        
        if(!chess.load_pgn(pgn)) return alert('Invalid PGN');
        
        gameMoves = [];
        let tempChess = new Chess();
        const history = chess.history({verbose: true});
        
        // Build move list
        gameMoves = history.map(m => {
            tempChess.move(m);
            return { fen: tempChess.fen(), san: m.san, color: m.color, eval: 0 };
        });

        if(gameMoves.length === 0) return alert('No moves found');

        showLoader('Initializing Stockfish...');
        document.getElementById('analysisDashboard').classList.remove('hidden');

        // Init Worker
        if(engine) engine.terminate();
        const stockfishUrl = 'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.js';
        
        try {
            // Try fetching for Blob (better for some browsers)
            const req = await fetch(stockfishUrl);
            const blob = await req.blob();
            engine = new Worker(URL.createObjectURL(blob));
        } catch(e) {
            // Fallback
            engine = new Worker(stockfishUrl);
        }

        engine.postMessage('uci');

        // Run Analysis Loop
        for(let i=0; i < gameMoves.length; i++) {
            if(myId !== currentAnalysisId) return; // Stop if restarted
            
            updateLoader(Math.round((i / gameMoves.length) * 100), `Analyzing move ${i+1}/${gameMoves.length}`);
            
            const score = await getMoveScore(gameMoves[i].fen, myId);
            if(myId !== currentAnalysisId) return;

            // Normalize Score (Engine is always "Side to move", we want "White perspective")
            const isWhiteTurn = gameMoves[i].color === 'w'; // White just moved, so it's Black's turn in FEN
            // Stockfish gives score for Black.
            // We want score for White.
            // So if White moved, and engine says +1 (Black winning), White score is -1.
            // If Black moved, and engine says +1 (White winning), White score is +1.
            
            // simpler: Stockfish gives score for "Side to Move".
            // If FEN is Black to move, +cp means Black is winning.
            // We want White perspective.
            // So if side-to-move is 'b', we invert.
            const sideToMove = gameMoves[i].fen.split(' ')[1];
            gameMoves[i].eval = (sideToMove === 'w') ? score : -score;
        }

        calcStats();
        renderUI();
        hideLoader();
        navMove('start');
    }

    function getMoveScore(fen, runId) {
        return new Promise(resolve => {
            const handler = (e) => {
                if(runId !== currentAnalysisId) {
                    engine.removeEventListener('message', handler);
                    return;
                }
                const line = e.data;
                if(line.startsWith('bestmove')) {
                    engine.removeEventListener('message', handler);
                    resolve(lastScore);
                }
                if(line.includes('score cp')) {
                    const parts = line.split(' ');
                    const idx = parts.indexOf('cp');
                    lastScore = parseInt(parts[idx + 1]);
                } else if(line.includes('score mate')) {
                    const parts = line.split(' ');
                    const idx = parts.indexOf('mate');
                    const mate = parseInt(parts[idx + 1]);
                    lastScore = mate > 0 ? 2000 : -2000;
                }
            };
            
            let lastScore = 0;
            engine.addEventListener('message', handler);
            engine.postMessage('position fen ' + fen);
            engine.postMessage('go movetime 100'); 
        });
    }

    function calcStats() {
        let wAcc = 0, bAcc = 0, wMoves = 0, bMoves = 0;
        let prevEval = 0;
        
        gameMoves.forEach(m => {
            let diff = m.eval - prevEval;
            // If White moved, positive diff is good.
            // If Black moved, negative diff is good (eval goes down).
            
            if(m.color === 'w') {
                // White moved. Did eval go up?
                // Actually, simple accuracy is usually based on "Centipawn Loss" (How much worse than best move)
                // Since we aren't calculating "Best Move" separately, we just check if eval dropped.
                // If eval dropped (e.g. 0.5 -> 0.0), White lost 50cp.
                let loss = prevEval - m.eval;
                if(loss < 0) loss = 0;
                wAcc += Math.max(0, 100 - (loss / 2)); // Simple rough formula
                wMoves++;
            } else {
                // Black moved. Did eval go UP? (e.g. 0.0 -> 0.5 means Black worsened position)
                let loss = m.eval - prevEval;
                if(loss < 0) loss = 0;
                bAcc += Math.max(0, 100 - (loss / 2));
                bMoves++;
            }
            prevEval = m.eval;
        });
        
        document.getElementById('accWhite').innerText = wMoves ? Math.round(wAcc / wMoves) + '%' : '-';
        document.getElementById('accBlack').innerText = bMoves ? Math.round(bAcc / bMoves) + '%' : '-';
    }

    function renderUI() {
        // Move List
        const list = document.getElementById('moveList');
        list.innerHTML = '';
        
        let html = '';
        for(let i=0; i<gameMoves.length; i+=2) {
            const w = gameMoves[i];
            const b = gameMoves[i+1];
            html += `
                <div class="move-row" id="row-${i/2}">
                    <div style="flex:0 0 30px; color:#666">${(i/2)+1}.</div>
                    <div onclick="navMove(${i})">${w.san} <small>${w.eval/100}</small></div>
                    ${b ? `<div onclick="navMove(${i+1})">${b.san} <small>${b.eval/100}</small></div>` : '<div></div>'}
                </div>
            `;
        }
        list.innerHTML = html;

        // Chart
        if(chartInstance) chartInstance.destroy();
        const ctx = document.getElementById('evalChart').getContext('2d');
        chartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                labels: gameMoves.map((_,i) => i+1),
                datasets: [{
                    label: 'Advantage (White)',
                    data: gameMoves.map(m => Math.max(-10, Math.min(10, m.eval/100))), // Clamp -10 to +10
                    borderColor: '#667eea',
                    pointRadius: 0,
                    tension: 0.2,
                    fill: { target: 'origin', above: 'rgba(102,126,234,0.2)', below: 'rgba(231,76,60,0.2)' }
                }]
            },
            options: { responsive: true, maintainAspectRatio: false, scales: { x: {display:false} }, plugins: {legend: {display:false}} }
        });
    }

    // --- Navigation ---
    function navMove(index) {
        if(typeof index === 'string') {
            if(index === 'start') currentMoveIndex = -1;
            else if(index === 'end') currentMoveIndex = gameMoves.length - 1;
            else if(index === 'prev') currentMoveIndex = Math.max(-1, currentMoveIndex - 1);
            else if(index === 'next') currentMoveIndex = Math.min(gameMoves.length - 1, currentMoveIndex + 1);
        } else {
            currentMoveIndex = index;
        }

        // Update Board
        const fen = currentMoveIndex === -1 ? 'start' : gameMoves[currentMoveIndex].fen;
        board.position(fen);

        // Highlight
        document.querySelectorAll('.move-row').forEach(e => e.classList.remove('active'));
        if(currentMoveIndex > -1) {
            const rowId = Math.floor(currentMoveIndex / 2);
            const el = document.getElementById('row-' + rowId);
            if(el) {
                el.classList.add('active');
                el.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
            
            // Eval Bar
            const sc = gameMoves[currentMoveIndex].eval; // in cp
            // Map -500..500 to 5%..95%
            let pct = 50 + (sc / 10);
            pct = Math.max(5, Math.min(95, pct));
            document.getElementById('evalBarFill').style.height = pct + '%';
            document.getElementById('evalBarFill').style.background = (sc > 0) ? '#fff' : '#444'; // Visual indicator
        }
    }

    function stopAnalysis() {
        currentAnalysisId++; // Kills the loop
        if(engine) engine.terminate();
        hideLoader();
    }

    function showLoader(txt) {
        document.getElementById('loader').style.display = 'flex';
        document.getElementById('loadingText').innerText = txt;
        document.getElementById('progressFill').style.width = '0%';
    }
    function updateLoader(pct, txt) {
        document.getElementById('progressFill').style.width = pct + '%';
        if(txt) document.getElementById('loadingText').innerText = txt;
    }
    function hideLoader() {
        document.getElementById('loader').style.display = 'none';
    }
</script>
</body>
</html>
