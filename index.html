<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lichess Player Statistics</title>
    
    <link rel="icon" type="image/png" sizes="32x32" href="https://lichess1.org/assets/logo/lichess-favicon-32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="https://lichess1.org/assets/logo/lichess-favicon-96.png">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #000000; color: #e0e0e0; min-height: 100vh; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; }
        
        /* Header */
        .header { text-align: center; color: white; margin-bottom: 30px; }
        .header h1 { font-size: 2.5rem; margin-bottom: 10px; }
        .header p { color: #888; }
        
        /* Tabs */
        .tabs { display: flex; justify-content: center; gap: 10px; margin-bottom: 30px; }
        .tab-btn { padding: 12px 30px; background: #1a1a1a; color: #888; border: 2px solid #333; border-radius: 8px; cursor: pointer; font-size: 1rem; font-weight: 600; transition: all 0.3s; }
        .tab-btn.active { background: white; color: black; border-color: white; }
        .tab-btn:hover { transform: translateY(-2px); }
        
        .view-section { display: none; }
        .view-section.active { display: block; }

        /* Cards */
        .card { background: white; padding: 25px; border-radius: 15px; margin-bottom: 20px; box-shadow: 0 10px 30px rgba(255,255,255,0.1); }
        .search-box { background: #1a1a1a; padding: 30px; border-radius: 15px; margin-bottom: 30px; box-shadow: 0 10px 30px rgba(255,255,255,0.1); }
        
        /* Input */
        .input-group { display: flex; gap: 10px; margin-bottom: 15px; }
        input, textarea { flex: 1; padding: 15px; background: #0a0a0a; border: 2px solid #333; color: white; border-radius: 8px; font-family: monospace; font-size: 1rem; transition: border-color 0.3s; outline: none; }
        input:focus, textarea:focus { border-color: #667eea; }
        textarea { font-family: 'Segoe UI', sans-serif; }
        
        button { padding: 15px 40px; background: white; color: black; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1rem; transition: transform 0.2s, box-shadow 0.2s; }
        button:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(255, 255, 255, 0.4); }
        button:active { transform: translateY(0); }
        button:disabled { opacity: 0.6; cursor: not-allowed; }
        
        /* Stats View */
        .player-info { color: #333; }
        .player-header { display: flex; align-items: center; gap: 20px; margin-bottom: 20px; }
        .player-header h2 { font-size: 2rem; color: #333; }
        .player-meta { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }
        .meta-item { padding: 10px; background: #f8f9fa; border-radius: 8px; color: #333; }
        .meta-item strong { color: #667eea; }
        
        .charts-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px; }
        .chart-container { background: white; padding: 20px; border-radius: 15px; box-shadow: 0 10px 30px rgba(255,255,255,0.1); }
        .chart-container h3 { margin-bottom: 15px; color: #333; text-align: center; }
        .chart-wrapper { position: relative; height: 300px; }

        /* Analysis Layout */
        .analysis-grid { display: grid; grid-template-columns: minmax(300px, 600px) 1fr; gap: 20px; }
        .board-wrapper { position: relative; }
        .board-container { display: flex; background: white; padding: 10px; border-radius: 15px; }
        #board { width: 100%; }
        
        /* Eval Bar */
        .eval-bar-container { width: 20px; background: #333; margin-right: 10px; position: relative; border-radius: 3px; overflow: hidden; }
        .eval-bar-fill { width: 100%; background: #eee; position: absolute; bottom: 0; height: 50%; transition: height 0.3s; }
        
        .move-list { height: 300px; overflow-y: auto; background: white; border: 1px solid #ddd; padding: 10px; font-family: monospace; border-radius: 8px; color: #333; }
        .move-row { display: flex; padding: 6px; border-bottom: 1px solid #eee; cursor: pointer; border-radius: 4px; }
        .move-row:hover { background: #f0f0f0; }
        .move-row.active { background: #667eea; color: white; border-left: 3px solid #333; }
        .move-row div { flex: 1; }
        
        .stat-box { background: white; padding: 20px; border-radius: 15px; margin-bottom: 15px; text-align: center; box-shadow: 0 10px 30px rgba(255,255,255,0.1); color: #333; }
        .stat-box h4 { margin-bottom: 10px; }
        .stat-value { font-size: 1.8rem; font-weight: bold; color: #667eea; }
        
        /* Progress Overlay */
        .progress-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.9); display: none; align-items: center; justify-content: center; z-index: 1000; }
        .progress-overlay.show { display: flex; }
        .progress-content { background: white; padding: 40px; border-radius: 15px; text-align: center; min-width: 400px; }
        .progress-content h3 { margin-bottom: 20px; color: #333; font-size: 1.5rem; }
        .progress-bar { width: 100%; height: 30px; background: #e0e0e0; border-radius: 15px; overflow: hidden; margin-bottom: 15px; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #667eea, #764ba2); width: 0%; transition: width 0.3s; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 0.9rem; }
        .progress-text { color: #666; font-size: 0.95rem; }
        .cancel-btn { margin-top: 15px; background: #ff4757; color: white; padding: 10px 20px; }
        
        /* Error/Loading */
        .error { background: #ff4757; color: white; padding: 15px; border-radius: 8px; display: none; margin-bottom: 15px; }
        .error.show { display: block; }
        .loading { text-align: center; color: white; font-size: 1.2rem; display: none; padding: 20px; }
        .loading.show { display: block; }
        
        /* Utilities */
        .hidden { display: none !important; }
        
        @media (max-width: 900px) { 
            .analysis-grid { grid-template-columns: 1fr; }
            .charts-grid { grid-template-columns: 1fr; }
            .input-group { flex-direction: column; }
        }
    </style>
</head>
<body>

<div class="container">
    <div class="header">
        <h1>Lichess Player Statistics</h1>
        <p>View detailed statistics and analyze your games</p>
        <div class="tabs">
            <button class="tab-btn active" onclick="switchTab('stats')">Player Stats</button>
            <button class="tab-btn" onclick="switchTab('analysis')">Game Analysis</button>
        </div>
    </div>

    <div class="error" id="globalError"></div>
    <div class="loading" id="globalLoading">Loading...</div>

    <!-- STATS VIEW -->
    <div id="statsView" class="view-section active">
        <div class="search-box">
            <div class="input-group">
                <input type="text" id="usernameInput" placeholder="Enter Lichess username">
                <button id="searchBtn">Search</button>
            </div>
        </div>
        
        <div id="statsContainer" class="hidden">
            <div class="card" id="playerInfo"></div>
            <div class="charts-grid" id="chartsGrid"></div>
        </div>
    </div>

    <!-- ANALYSIS VIEW -->
    <div id="analysisView" class="view-section">
        <div class="search-box">
            <div class="input-group">
                <input type="text" id="gameUrlInput" placeholder="Game URL or ID (e.g. https://lichess.org/abc12345)">
                <button onclick="loadFromUrl()">Load Game</button>
            </div>
            <textarea id="pgnInput" rows="4" placeholder="Or paste PGN here..."></textarea>
            <button onclick="startAnalysis()" style="width:100%; margin-top:15px;">Start Deep Analysis</button>
        </div>

        <div id="analysisDashboard" class="hidden">
            <div class="analysis-grid">
                <div class="board-wrapper">
                    <div class="board-container">
                        <div class="eval-bar-container"><div class="eval-bar-fill" id="evalBarFill"></div></div>
                        <div id="board"></div>
                    </div>
                    <div style="margin-top:15px; display:flex; gap:8px; justify-content:center;">
                        <button onclick="navMove('start')">⏮</button>
                        <button onclick="navMove('prev')">◀</button>
                        <button onclick="navMove('next')">▶</button>
                        <button onclick="navMove('end')">⏭</button>
                        <button onclick="board.flip()">⇅ Flip</button>
                    </div>
                </div>

                <div>
                    <div class="stat-box">
                        <h4>Accuracy Estimate</h4>
                        <div style="display:flex; justify-content:space-around; margin-top:10px;">
                            <div><strong>White:</strong> <div class="stat-value" id="accWhite">-</div></div>
                            <div><strong>Black:</strong> <div class="stat-value" id="accBlack">-</div></div>
                        </div>
                    </div>
                    <div class="move-list" id="moveList"></div>
                    <div class="card" style="margin-top:20px; height:200px;">
                        <canvas id="evalChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Progress Overlay -->
<div class="progress-overlay" id="progressOverlay">
    <div class="progress-content">
        <h3 id="progressTitle">Processing...</h3>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill">0%</div>
        </div>
        <p class="progress-text" id="progressText">Initializing...</p>
        <button class="cancel-btn" id="cancelBtn" onclick="cancelProgress()">Cancel</button>
    </div>
</div>

<script>
    // --- Global State ---
    let chess = new Chess();
    let board = null;
    let engine = null;
    let currentAnalysisId = 0;
    let gameMoves = [];
    let currentMoveIndex = -1;
    let evalChartInstance = null;
    let statsCharts = [];
    let currentUser = null;
    let cancelRequested = false;

    // --- Tab Handling ---
    function switchTab(tab) {
        document.querySelectorAll('.view-section').forEach(e => e.classList.remove('active'));
        document.querySelectorAll('.tab-btn').forEach(e => e.classList.remove('active'));
        document.getElementById(tab + 'View').classList.add('active');
        
        const btns = document.querySelectorAll('.tab-btn');
        if(tab === 'stats') btns[0].classList.add('active');
        if(tab === 'analysis') btns[1].classList.add('active');

        if(tab === 'analysis') {
            setTimeout(() => {
                if(!board) {
                    initBoard();
                } else {
                    board.resize();
                }
            }, 50);
        }
    }

    function initBoard() {
        board = Chessboard('board', {
            position: 'start',
            draggable: false,
            pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png'
        });
        window.onresize = () => board && board.resize();
    }

    // --- Error/Loading Helpers ---
    function showError(msg) {
        const el = document.getElementById('globalError');
        el.textContent = msg;
        el.classList.add('show');
        setTimeout(() => el.classList.remove('show'), 5000);
    }

    function showLoading(show) {
        document.getElementById('globalLoading').classList.toggle('show', show);
    }

    function showProgress(title, text) {
        document.getElementById('progressTitle').textContent = title;
        document.getElementById('progressText').textContent = text;
        document.getElementById('progressFill').style.width = '0%';
        document.getElementById('progressFill').textContent = '0%';
        document.getElementById('progressOverlay').classList.add('show');
        cancelRequested = false;
    }

    function updateProgress(percent, text) {
        document.getElementById('progressFill').style.width = percent + '%';
        document.getElementById('progressFill').textContent = percent + '%';
        if(text) document.getElementById('progressText').textContent = text;
    }

    function hideProgress() {
        document.getElementById('progressOverlay').classList.remove('show');
    }

    function cancelProgress() {
        cancelRequested = true;
        currentAnalysisId++;
        if(engine) engine.terminate();
        hideProgress();
    }

    // --- STATS VIEW ---
    const searchBtn = document.getElementById('searchBtn');
    const usernameInput = document.getElementById('usernameInput');

    usernameInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') searchBtn.click();
    });

    searchBtn.addEventListener('click', async () => {
        const username = usernameInput.value.trim();
        if (!username) return showError('Please enter a username');

        showLoading(true);
        document.getElementById('statsContainer').classList.add('hidden');
        searchBtn.disabled = true;

        statsCharts.forEach(chart => chart.destroy());
        statsCharts = [];

        try {
            const res = await fetch(`https://lichess.org/api/user/${username}`);
            if (!res.ok) throw new Error('User not found');
            const user = await res.json();
            currentUser = user;

            displayPlayerInfo(user);
            await displayCharts(user, username);

            document.getElementById('statsContainer').classList.remove('hidden');
        } catch (error) {
            showError(error.message);
        } finally {
            showLoading(false);
            searchBtn.disabled = false;
        }
    });

    function displayPlayerInfo(user) {
        const createdDate = new Date(user.createdAt).toLocaleDateString();
        const seenDate = user.seenAt ? new Date(user.seenAt).toLocaleDateString() : 'N/A';
        const playTimeHours = user.playTime?.total ? Math.round(user.playTime.total / 3600) : 0;
        const totalGames = user.count?.all || 0;

        document.getElementById('playerInfo').innerHTML = `
            <div class="player-header">
                <h2>${user.username}</h2>
                ${user.title ? `<span style="background: #ffd700; padding: 5px 10px; border-radius: 5px; font-weight: bold; color: #333;">${user.title}</span>` : ''}
            </div>
            <div class="player-meta">
                <div class="meta-item"><strong>Member since:</strong> ${createdDate}</div>
                <div class="meta-item"><strong>Last seen:</strong> ${seenDate}</div>
                <div class="meta-item"><strong>Play time:</strong> ${playTimeHours} hours</div>
                <div class="meta-item"><strong>Games played:</strong> ${totalGames}</div>
            </div>
        `;
    }

    async function displayCharts(user, username) {
        const chartsGrid = document.getElementById('chartsGrid');
        chartsGrid.innerHTML = '';

        // Ratings Chart
        const gameTypes = ['bullet', 'blitz', 'rapid', 'classical', 'correspondence'];
        const ratings = [];
        const ratingLabels = [];
        const ratingColors = [];
        
        gameTypes.forEach(type => {
            if (user.perfs?.[type]?.rating) {
                ratingLabels.push(type.charAt(0).toUpperCase() + type.slice(1));
                ratings.push(user.perfs[type].rating);
                
                const colorMap = {
                    bullet: 'rgba(139, 0, 0, 0.8)',
                    blitz: 'rgba(220, 20, 60, 0.8)',
                    rapid: 'rgba(255, 140, 0, 0.8)',
                    classical: 'rgba(255, 215, 0, 0.8)',
                    correspondence: 'rgba(128, 128, 128, 0.8)'
                };
                ratingColors.push(colorMap[type] || 'rgba(102, 126, 234, 0.8)');
            }
        });

        if (ratings.length > 0) {
            createChart('Ratings by Game Type', ratingLabels, ratings, 'bar', ratingColors);
        }

        // Win/Loss/Draw
        if (user.count) {
            const gameResults = [user.count.win || 0, user.count.loss || 0, user.count.draw || 0];
            createChart('Win/Loss/Draw', ['Wins', 'Losses', 'Draws'], gameResults, 'doughnut', 
                ['rgba(46, 213, 115, 0.8)', 'rgba(255, 71, 87, 0.8)', 'rgba(158, 158, 158, 0.8)']);
        }

        // Games by Type
        const gameModes = [];
        const gameModeLabels = [];
        const gameModeColors = [];
        gameTypes.forEach(type => {
            if (user.perfs?.[type]?.games > 0) {
                gameModeLabels.push(type.charAt(0).toUpperCase() + type.slice(1));
                gameModes.push(user.perfs[type].games);
                
                const colorMap = {
                    bullet: 'rgba(139, 0, 0, 0.8)',
                    blitz: 'rgba(220, 20, 60, 0.8)',
                    rapid: 'rgba(255, 140, 0, 0.8)',
                    classical: 'rgba(255, 215, 0, 0.8)',
                    correspondence: 'rgba(128, 128, 128, 0.8)'
                };
                gameModeColors.push(colorMap[type]);
            }
        });

        if (gameModes.length > 0) {
            createChart('Games by Type', gameModeLabels, gameModes, 'pie', gameModeColors);
        }

        // Advanced Stats from Games
        try {
            showProgress('Loading Game Data', 'Connecting to Lichess...');
            updateProgress(20, 'Downloading games...');

            const gamesRes = await fetch(`https://lichess.org/api/games/user/${username}?max=300&pgnInJson=true&opening=true`);
            
            updateProgress(50, 'Processing game data...');
            const gamesText = await gamesRes.text();
            
            updateProgress(75, 'Analyzing statistics...');
            const games = gamesText.trim().split('\n').filter(line => line).map(line => JSON.parse(line));

            if (games.length > 0) {
                displayAdvancedStats(games, user);
            }

            updateProgress(100, 'Complete!');
            setTimeout(hideProgress, 500);
        } catch (error) {
            console.error('Error fetching games:', error);
            hideProgress();
        }
    }

    function displayAdvancedStats(games, user) {
        const openingStats = {};

        games.forEach(game => {
            const isWhite = game.players.white.user?.name.toLowerCase() === user.username.toLowerCase();

            if (game.opening?.name) {
                const opening = game.opening.name;
                if (!openingStats[opening]) {
                    openingStats[opening] = { wins: 0, losses: 0, draws: 0 };
                }
                
                const result = isWhite ? 
                    (game.winner === 'white' ? 'wins' : game.winner === 'black' ? 'losses' : 'draws') :
                    (game.winner === 'black' ? 'wins' : game.winner === 'white' ? 'losses' : 'draws');
                
                openingStats[opening][result]++;
            }
        });

        const topOpenings = Object.entries(openingStats)
            .sort((a, b) => (b[1].wins + b[1].losses + b[1].draws) - (a[1].wins + a[1].losses + a[1].draws))
            .slice(0, 5);

        if (topOpenings.length > 0) {
            const openingLabels = topOpenings.map(([name]) => name.length > 25 ? name.substring(0, 25) + '...' : name);
            const openingWinrates = topOpenings.map(([_, stats]) => {
                const total = stats.wins + stats.losses + stats.draws;
                return Math.round((stats.wins / total) * 100);
            });

            createChart('Winrate on Top 5 Openings', openingLabels, openingWinrates, 'bar', ['rgba(46, 213, 115, 0.8)']);
        }
    }

    function createChart(title, labels, data, type, colors) {
        const container = document.createElement('div');
        container.className = 'chart-container';
        container.innerHTML = `
            <h3>${title}</h3>
            <div class="chart-wrapper"><canvas></canvas></div>
        `;
        document.getElementById('chartsGrid').appendChild(container);

        const ctx = container.querySelector('canvas').getContext('2d');
        
        const chart = new Chart(ctx, {
            type: type,
            data: {
                labels: labels,
                datasets: [{
                    label: title,
                    data: data,
                    backgroundColor: colors,
                    borderColor: colors.map(c => c.replace('0.8', '1')),
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: type === 'doughnut' || type === 'pie',
                        position: 'bottom'
                    }
                },
                scales: type === 'bar' ? { y: { beginAtZero: true } } : {}
            }
        });

        statsCharts.push(chart);
    }

    // --- ANALYSIS VIEW ---
    async function loadFromUrl() {
        const input = document.getElementById('gameUrlInput').value.trim();
        const match = input.match(/lichess\.org\/([a-zA-Z0-9]{8})/);
        const id = match ? match[1] : input;
        
        if(!id || id.length !== 8) return showError('Invalid game ID or URL');
        
        showProgress('Loading Game', 'Downloading from Lichess...');
        
        try {
            const res = await fetch(`https://lichess.org/api/game/${id}?pgnInJson=true&clocks=false&evals=false`);
            if(!res.ok) throw new Error('Game not found');
            const data = await res.json();
            document.getElementById('pgnInput').value = data.pgn;
            
            hideProgress();
            startAnalysis(); 
        } catch(e) {
            hideProgress();
            showError(e.message);
        }
    }

    async function startAnalysis() {
        const pgn = document.getElementById('pgnInput').value.trim();
        if(!pgn) return showError('Please enter a PGN or load a game');

        currentAnalysisId++;
        const myId = currentAnalysisId;
        
        if(!chess.load_pgn(pgn)) return showError('Invalid PGN format');
        
        gameMoves = [];
        let tempChess = new Chess();
        const history = chess.history({verbose: true});
        
        gameMoves = history.map(m => {
            tempChess.move(m);
            return { fen: tempChess.fen(), san: m.san, color: m.color, eval: 0 };
        });

        if(gameMoves.length === 0) return showError('No moves found in PGN');

        document.getElementById('analysisDashboard').classList.remove('hidden');
        if(!board) initBoard();
        setTimeout(() => board.resize(), 100);
        
        renderMoveList();
        showProgress('Analyzing Game', 'Initializing Stockfish engine...');

        // Initialize STRONGER Engine
        if(engine) engine.terminate();
        
        try {
            // Try Stockfish 14 (much stronger than 10.0.2)
            const stockfishUrl = 'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.js';
            const req = await fetch(stockfishUrl);
            const blob = await req.blob();
            engine = new Worker(URL.createObjectURL(blob));
        } catch(e) {
            engine = new Worker('https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.js');
        }

        engine.postMessage('uci');
        engine.postMessage('setoption name Threads value 4');
        engine.postMessage('setoption name Hash value 256');
        engine.postMessage('setoption name MultiPV value 1');

        updateProgress(10, 'Engine ready. Starting analysis...');

        // Analysis Loop
        for(let i = 0; i < gameMoves.length; i++) {
            if(myId !== currentAnalysisId || cancelRequested) return;
            
            const progress = Math.round((i / gameMoves.length) * 90) + 10;
            updateProgress(progress, `Analyzing move ${i+1} of ${gameMoves.length}`);
            
            board.position(gameMoves[i].fen);
            highlightMoveRow(i);
            
            const score = await getMoveScore(gameMoves[i].fen, myId);
            if(myId !== currentAnalysisId || cancelRequested) return;

            const sideToMove = gameMoves[i].fen.split(' ')[1];
            gameMoves[i].eval = (sideToMove === 'w') ? score : -score;
            
            if(i % 3 === 0) updateEvalGraph();
        }

        calcAccuracy();
        updateEvalGraph();
        updateProgress(100, 'Analysis complete!');
        setTimeout(hideProgress, 800);
        navMove('start');
    }

    function getMoveScore(fen, runId) {
        return new Promise(resolve => {
            let lastScore = 0;
            
            const handler = (e) => {
                if(runId !== currentAnalysisId || cancelRequested) {
                    engine.removeEventListener('message', handler);
                    resolve(lastScore);
                    return;
                }
                
                const line = e.data;
                
                if(line.startsWith('bestmove')) {
                    engine.removeEventListener('message', handler);
                    resolve(lastScore);
                }
                
                if(line.includes('score cp')) {
                    const parts = line.split(' ');
                    const idx = parts.indexOf('cp');
                    lastScore = parseInt(parts[idx + 1]);
                } else if(line.includes('score mate')) {
                    const parts = line.split(' ');
                    const idx = parts.indexOf('mate');
                    const mate = parseInt(parts[idx + 1]);
                    lastScore = mate > 0 ? 3000 : -3000;
                }
            };
            
            engine.addEventListener('message', handler);
            engine.postMessage('position fen ' + fen);
            // CRITICAL: Use depth 18 for ~2400+ Elo strength
            engine.postMessage('go depth 18');
        });
    }

    function calcAccuracy() {
        if(gameMoves.length < 2) return;
        
        let whiteAcc = [];
        let blackAcc = [];
        
        for(let i = 1; i < gameMoves.length; i++) {
            const prevEval = gameMoves[i-1].eval;
            const currEval = gameMoves[i].eval;
            const color = gameMoves[i-1].color;
            
            // Calculate centipawn loss
            const loss = Math.abs(currEval - prevEval);
            
            // Convert to accuracy (Lichess-like formula)
            // Perfect move = 100%, each 100cp loss ~= 10% accuracy drop
            const moveAcc = Math.max(0, 100 - (loss / 10));
            
            if(color === 'w') {
                whiteAcc.push(moveAcc);
            } else {
                blackAcc.push(moveAcc);
            }
        }
        
        const avgWhite = whiteAcc.length > 0 ? Math.round(whiteAcc.reduce((a,b) => a+b, 0) / whiteAcc.length) : 0;
        const avgBlack = blackAcc.length > 0 ? Math.round(blackAcc.reduce((a,b) => a+b, 0) / blackAcc.length) : 0;
        
        document.getElementById('accWhite').textContent = avgWhite + '%';
        document.getElementById('accBlack').textContent = avgBlack + '%';
    }

    function renderMoveList() {
        const html = gameMoves.map((m, i) => {
            const num = Math.floor(i/2) + 1;
            const isWhite = i % 2 === 0;
            return `
                <div class="move-row" onclick="gotoMove(${i})" data-move="${i}">
                    <div>${isWhite ? num + '.' : ''}</div>
                    <div>${m.san}</div>
                    <div id="eval-${i}">...</div>
                </div>
            `;
        }).join('');
        document.getElementById('moveList').innerHTML = html;
    }

    function gotoMove(idx) {
        currentMoveIndex = idx;
        board.position(idx < 0 ? 'start' : gameMoves[idx].fen);
        updateEvalBar(idx < 0 ? 0 : gameMoves[idx].eval);
        highlightMoveRow(idx);
    }

    function navMove(dir) {
        if(dir === 'start') gotoMove(-1);
        else if(dir === 'end') gotoMove(gameMoves.length - 1);
        else if(dir === 'prev') gotoMove(Math.max(-1, currentMoveIndex - 1));
        else if(dir === 'next') gotoMove(Math.min(gameMoves.length - 1, currentMoveIndex + 1));
    }

    function highlightMoveRow(idx) {
        document.querySelectorAll('.move-row').forEach(r => r.classList.remove('active'));
        if(idx >= 0) {
            const row = document.querySelector(`[data-move="${idx}"]`);
            if(row) {
                row.classList.add('active');
                row.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }
    }

    function updateEvalBar(score) {
        const clamped = Math.max(-1000, Math.min(1000, score));
        const percent = 50 + (clamped / 2000) * 50;
        document.getElementById('evalBarFill').style.height = percent + '%';
    }

    function updateEvalGraph() {
        const ctx = document.getElementById('evalChart');
        if(!ctx) return;
        
        const labels = gameMoves.map((_, i) => Math.floor(i/2) + 1 + (i % 2 === 0 ? '' : '...'));
        const data = gameMoves.map(m => Math.max(-10, Math.min(10, m.eval / 100)));
        
        if(evalChartInstance) evalChartInstance.destroy();
        
        evalChartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Evaluation',
                    data: data,
                    borderColor: 'rgba(102, 126, 234, 1)',
                    backgroundColor: 'rgba(102, 126, 234, 0.1)',
                    tension: 0.3,
                    fill: true
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { legend: { display: false } },
                scales: {
                    y: {
                        min: -10,
                        max: 10,
                        ticks: {
                            callback: (val) => val > 0 ? '+' + val : val
                        }
                    }
                }
            }
        });
        
        // Update move list evals
        gameMoves.forEach((m, i) => {
            const el = document.getElementById(`eval-${i}`);
            if(el) {
                const cp = m.eval;
                const display = Math.abs(cp) > 300 ? (cp > 0 ? 'M' : '-M') : (cp > 0 ? '+' : '') + (cp/100).toFixed(1);
                el.textContent = display;
            }
        });
    }

    // Initialize on load
    window.addEventListener('DOMContentLoaded', () => {
        initBoard();
    });
</script>

</body>
</html>
